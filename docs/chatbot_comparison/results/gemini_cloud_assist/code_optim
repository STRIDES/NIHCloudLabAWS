#!/bin/bash

# Use more descriptive variable names
input_dir="/home/ramsivakumar/nextflow_conversion/fastq"
output_dir="/home/ramsivakumar/nextflow_conversion/test_out_bash"

# Create all output directories at once
mkdir -p "$output_dir/fastp_output" "$output_dir/fastqc_output" "$output_dir/multiqc_output" "$output_dir/unicycler_output"

# Use find to iterate over R1 files and extract sample names
find "$input_dir" -name "*_R1_001.fastq.gz" -print0 | while IFS= read -r -d $'\0' fastq_file_r1; do
  # Extract sample name using bash parameter expansion
  sample_name="${fastq_file_r1##*/}"
  sample_name="${sample_name%_R1_001.fastq.gz}"

  fastq_file_r2="${input_dir}/${sample_name}_R2_001.fastq.gz"

  # Check if both R1 and R2 exist and are files. Exit if not.
  if [[ ! -f "$fastq_file_r1" ]] || [[ ! -f "$fastq_file_r2" ]]; then
    echo "Error: Input files not found for $sample_name. Exiting." >&2  #Redirect to stderr
    exit 1 # Exit with non-zero status to indicate error
  fi


  # Define output file/directory prefixes for better organization
  fastp_prefix="$output_dir/fastp_output/${sample_name}"
  fastqc_prefix="$output_dir/fastqc_output/${sample_name}"
  unicycler_prefix="$output_dir/unicycler_output/${sample_name}"

  # Step 1: Run fastp with error checking
  if ! fastp -i "$fastq_file_r1" -I "$fastq_file_r2" -o "${fastp_prefix}_R1.fastp.fastq" -O "${fastp_prefix}_R2.fastp.fastq"; then
    echo "Error: fastp failed for $sample_name. Exiting." >&2
    exit 1
  fi

  # Step 2: Run fastqc with error checking
  if ! fastqc "${fastp_prefix}_R1.fastp.fastq" "${fastp_prefix}_R2.fastp.fastq" -o "$output_dir/fastqc_output"; then  # Output to the main fastqc dir
    echo "Error: fastqc failed for $sample_name. Exiting." >&2
    exit 1
  fi

  # Step 3: Run multiqc after the loop (more efficient)


  # Step 4: Run unicycler with error checking
  if ! unicycler -1 "${fastp_prefix}_R1.fastp.fastq" -2 "${fastp_prefix}_R2.fastp.fastq" -o "$unicycler_prefix"; then
      echo "Error: unicycler failed for $sample_name. Exiting." >&2
      exit 1
  fi

  echo "Finished processing $sample_name."
done

# Run multiqc once outside the loop
multiqc "$output_dir/fastqc_output" -o "$output_dir/multiqc_output"

echo "All files processed."

Key improvements:

Error Handling: Added if ! command; then ... fi blocks to check the exit status of each command and exit if any command fails. Error messages are sent to standard error (>&2).
File Existence Checks: More robust checking for both R1 and R2 files before processing.
Sample Name Extraction: Uses bash parameter expansion for more efficient and clear sample name extraction.
Looping with find: Uses find with -print0 and while IFS= read -r -d $'\0' to handle filenames with spaces and special characters safely. Only loops through R1 files and constructs R2 filenames based on R1.
Output Directory Management: Creates all output directories at the beginning. Uses prefixes for output file names, making organization cleaner. fastqc outputs are put directly into the fastqc output folder, and multiqc is run only once, outside the loop.
Readability: More descriptive variable names and comments.
Efficiency: Running multiqc once outside the loop is more efficient than running it repeatedly inside the loop.
This revised script is more robust, efficient, and easier to understand and maintain. It also incorporates best practices for error handling and file management in bash scripts.

Rate this answer: 
